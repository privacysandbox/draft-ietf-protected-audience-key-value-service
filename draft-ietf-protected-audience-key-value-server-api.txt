



Network Working Group                                              P. Hu
Internet-Draft                                            B. R. Hamilton
Intended status: Standards Track                                  Google
Expires: 24 February 2025                                 23 August 2024


                Protected Audience Key Value Server APIs
       draft-ietf-protected-audience-key-value-server-api-latest

Abstract

   TODO Abstract

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://privacysandbox.github.io/draft-ietf-protected-audience-key-
   value-service/draft-ietf-protected-audience-key-value-server-
   api.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-ietf-protected-audience-key-
   value-server-api/.

   Source for this draft and an issue tracker can be found at
   https://github.com/privacysandbox/draft-ietf-protected-audience-key-
   value-service.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 24 February 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
     2.1.  Core data
       2.1.1.  Request
       2.1.2.  Schema of the request
       2.1.3.  Schema of the Response
       2.1.4.  Structured keys response specification
   3.  IANA Considerations
   4.  Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   TODO

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Core data

   Core request and response data structures are all in [CBOR].

   The schema below is defined following the [CDDL]

2.1.1.  Request

   *  Each request contains one or more partitions.  Each partition is a
      collection of keys that can be processed together by the service
      without any potential privacy leakage.  Keys from one interest
      group must be in the same partition.  Keys from different interest
      groups with the same joining site may or may not be in the same
      partition, so the server User Defined Functions should not make
      any assumptions based on that.

   *  Each partition contains one or more key groups.  Each key group
      has its unique attributes among all key groups in the partition.
      The attributes are represented by a list of “Tags”. Besides tags,
      the key group contains a list of keys to look up.

   *  Each partition has a unique id.

   *  Each partition has a compression group field.  Results of
      partitions belonging to the same compression group can be
      compressed together in the response.  Different compression groups
      must be compressed separately.  See more details below.  The
      expected use case by the client is that interest groups from the
      same joining origin and owner can be in the same compression
      group.

   TODO

2.1.2.  Schema of the request

   request = {
       ? acceptCompression: [* tstr],
       ; must contain at least one of none, gzip, brotli
       partitions: [* partition],
       ; A list of partitions. Each must be processed independently. Accessible by UDF.
   }

   partition = {
       id: uint,
       ; Unique id of the partition in this request
       compressionGroupId: uint,
       ; Unique id of a compression group in this request. Only partitions belonging to the same compression group will be compressed together in the response
       ? metadata: partitionMetadata,
       arguments: [* requestArgument],
       ; One group of keys and common attributes about them
   }
   ;Single partition object. A collection of keys that can be processed together.


   partitionMetadata = {
       ? hostname: tstr,
       ; The hostname of the top-level frame calling runAdAuction
       ? experimentGroupId: tstr,
       ? slotSize: tstr,
       ; Available if trustedBiddingSignalsSlotSizeMode=slot-size. In the form of <width>,<height>
       ? allSlotsRequestedSizes: tstr,
       ; Available if trustedBiddingSignalsSlotSizeMode=all-slots-requested-sizes. In the form of <width1>,<height1>,<width2>,<height2>,...
   }

   requestArgument = {
       ? tags: [* tstr],
       ; List of tags describing this group's attributes
       ? data: [* tstr],
       ; List of keys to get values for
   }

2.1.2.1.  Available Tags

   +=========+===========+=====================+=========================+
   |Tag      |Category   |Tag                  |Description              |
   |category |description|                     |                         |
   +=========+===========+=====================+=========================+
   |Namespace|Each key   |interestGroupNames   |Names of interest groups |
   |         |group has  |                     |in the encompassing      |
   |         |exactly one|                     |partition.               |
   |         |tag from   |                     |                         |
   |         |this       |                     |                         |
   |         |category.  |                     |                         |
   +---------+-----------+---------------------+-------------------------+
   |         |           |keys                 |“keys” is a list of      |
   |         |           |                     |trustedBiddingSignalsKeys|
   |         |           |                     |strings.                 |
   +---------+-----------+---------------------+-------------------------+
   |         |           |renderUrls           |Similarly, sellers may   |
   |         |           |                     |want to fetch information|
   |         |           |                     |about a specific         |
   |         |           |                     |creative, e.g. the       |
   |         |           |                     |results of some out-of-  |
   |         |           |                     |band ad scanning system. |
   |         |           |                     |This works in much the   |
   |         |           |                     |same way, with the base  |
   |         |           |                     |URL coming from the      |
   |         |           |                     |trustedScoringSignalsUrl |
   |         |           |                     |property of the seller's |
   |         |           |                     |auction configuration    |
   |         |           |                     |object.                  |
   +---------+-----------+---------------------+-------------------------+
   |         |           |adComponentRenderUrls|                         |
   +---------+-----------+---------------------+-------------------------+

                                  Table 1

   TODO: see if the above can be improved

   Example trusted bidding signals request from Chrome: The cbor
   representation consists of the following item, represented using the
   extended diagnostic notation from [CDDL] appendix G:

   {
     "acceptCompression": [
       "none",
       "gzip"
     ],
     "partitions": [
       {
         "id": 0,
         "compressionGroupId": 0,
         "metadata": {
           "hostname": "example.com",
           "experimentGroupId": "12345",
           "slotSize": "100,200",
         },
         "arguments": [
           {
             "tags": [
               "interestGroupNames"
             ],
             "data": [
               "InterestGroup1"
             ]
           },
           {
             "tags": [
               "keys"
             ],
             "data": [
               "keyAfromInterestGroup1",
               "keyBfromInterestGroup1"
             ]
           }
         ]
       },
       {
         "id": 1,
         "compressionGroupId": 0,
         "arguments": [
           {
             "tags": [
               "interestGroupNames"
             ],
             "data": [
               "InterestGroup2",
               "InterestGroup3"
             ]
           },
           {
             "tags": [
               "keys"
             ],
             "data": [
               "keyMfromInterestGroup2",
               "keyNfromInterestGroup3"
             ]
           }
         ]
       }
     ]
   }

2.1.3.  Schema of the Response

2.1.3.1.  Response

   The response is compressed.  Due to security and privacy reasons the
   compression is applied independently to each compression group.  That
   means, The response object mainly contains a list of compressed
   blobs, each for one compression group.  Each blob is for outputs of
   one or more partitions, sharing the same compressionGroup value as
   specified in the request.

   response = {
     ? compressionGroups : [* compressionGroup]
   }

   compressionGroup = {
     ? compressionGroupId: uint,
     ? ttl_ms: uint,
     ; Adtech-specified TTL for client-side caching. In milliseconds. Unset means no caching.
     ? content: bstrs
     ; Compressed CBOR binary string using the algorithm specified in the request
     ; For details see compressed response content schema below.
   }

2.1.3.1.1.  CompressionGroup

   The content of each compressed blob is a CBOR list of partition
   outputs.  This object contains actual key value results for
   partitions in the corresponding compression group.

   [* partitionOutput]
   ; Array of PartitionOutput objects

   partitionOutput = {
     ? id: uint
     ; Unique id of the partition from the request
     ? keyGroupOutputs: [* keyGroupOutput]
   }

   keyGroupOutput = {
     tags: [* tstr]
     ; List of tags describing this key group's attributes
     ? keyValues: {
       ; At least one key-value pair if present
       * tstr => keyValue
     }
     ; One value to be returned in response for one key
     ; If a keyValues object exists, it must at least contain one key-value pair. If no key-value pair can be returned, the key group should not be in the response
   }

   keyValue = {
     value: tstr
   }

   Example:

   [
     {
       "id": 0,
       "keyGroupOutputs": [
         {
           "tags": [
             "interestGroupNames"
           ],
           "keyValues": {
             "InterestGroup1": {
               "value": "{\"priorityVector\":{\"signal1\":1}}"
             }
           }
         },
         {
           "tags": [
             "keys"
           ],
           "keyValues": {
             "keyAfromInterestGroup1": {
               "value": "valueForA"
             },
             "keyBfromInterestGroup1": {
               "value":"[\"value1ForB\",\"value2ForB\"]"
             }
           }
         }
       ]
     }
   ]

2.1.4.  Structured keys response specification

   Structured keys are keys that the browser is aware of and the browser
   can use the response to do additional processing.  The value of these
   keys must abide by the following schema for the browser to
   successfully parse them.

   Note that they must be serialized to string when stored as the value.

2.1.4.1.  InterestGroupResponse

   The schema below is defined following the spec by https://json-
   schema.org/ For values for keys from the interestGroupNames
   namespace, they must conform to the following schema, prior to being
   serialized to string:

   {
     "title": "tkv.response.v2.InterestGroupResponse",
     "description": "Format for value of keys in groups tagged 'interestGroupNames'",
     "type": "object",
     "additionalProperties": false,
     "properties": {
       "priorityVector": {
         "type": "object",
         "patternProperties": {
           ".*": {
             "description": "signals",
             "type": "number"
           }
         }
       },
       "updateIfOlderThanMs": {
         "description": "This optional field specifies that the interest group should be updated if the interest group hasn't been joined or updated in a duration of time exceeding `updateIfOlderThanMs` milliseconds. Updates that ended in failure, either parse or network failure, are not considered to increment the last update or join time. An `updateIfOlderThanMs` that's less than 10 minutes will be clamped to 10 minutes.",
         "type": "unsigned integer"
       }
     }
   }

   Example:

   {
     "priorityVector": {
       "signal1": 1,
       "signal2": 2
     },
     "updateIfOlderThanMs": 10000
   }

3.  IANA Considerations

   This document has no IANA actions.

4.  Normative References

   [CBOR]     Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/rfc/rfc8949>.

   [CDDL]     Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/rfc/rfc8610>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Peiwen Hu
   Google
   Email: peiwenhu@google.com


   Benjamin Russ Hamilton
   Google
   Email: behamilton@google.com
